<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">云潮逸动，千流瀚疾</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-集合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/14/%E9%9B%86%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2023-12-14T12:49:55.890Z" itemprop="datePublished">2023-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="集合-Collection类族"><a href="#集合-Collection类族" class="headerlink" title="集合(Collection类族)"></a>集合(Collection类族)</h1><p><strong>集合类中存储的仅仅是对象的引用(堆地址，而非实际对象本身)，并不存储对象本身</strong><br>集合中<strong>不能添加基本数据类型，只能包含引用类型</strong>；<strong>部分基本数据类型在添加过程中会自动装箱包装成类</strong>，再添加到集合中<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32809926/1694499528690-98a63c46-69c3-45af-9003-6c4fead2c50d.png#averageHue=%23e0efe8&from=url&id=WaX1i&originHeight=1341&originWidth=2794&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2023/png/32809926/1694499528876-17995c63-c881-4c44-9f1e-4cd497ebddd7.png#averageHue=%23fcfcfa&from=url&id=UgM3R&originHeight=938&originWidth=2042&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>图中的绿色的虚线代表实现，绿色实线代表接口之间的继承，蓝色实线代表类之间的继承。</p>
<h2 id="List-Set-Queue-Map-四者的区别？"><a href="#List-Set-Queue-Map-四者的区别？" class="headerlink" title="List, Set, Queue, Map 四者的区别？"></a>List, Set, Queue, Map 四者的区别？</h2><ul>
<li>List(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li>Set(注重独一无二的性质): 存储的元素不可重复的。</li>
<li>Queue(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li>Map(用 key 来搜索的专家): 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre><code class="java">//创建一个元素为1，2，3的集合并遍历打印（使用lambda中的方法引用System.out::println）
List.of(1,2,3).forEach(System.out::println);
</code></pre>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>Object[] 数组。详细可以查看：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/arraylist-source-code.html#arraylist-%E7%AE%80%E4%BB%8B">源码分析</a><br>:::info<br>ArrayList 的增删本质上是列表的复制，本质上使用的都是下面的方法<br>将原本的列表数据向前或向后移动，就是使用了下方的方法重新拷贝了原列表<br>:::</p>
<pre><code class="java">@IntrinsicCandidate
public static native void arraycopy(Object src,  int  srcPos,
                                    Object dest, int destPos,
                                    int length);
</code></pre>
<p>ArrayList 常见问题</p>
<ol>
<li>ArrayList 中可以添加 null 吗?</li>
<li>可以添加但没有实际意义。ArrayList 可以添加任何类型对象。</li>
<li>xx</li>
</ol>
<p><code>ArrayList</code>的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 ArrayList 实例的容量。这可以减少递增式再分配的数量。<br><code>ArrayList</code> 继承于 <code>AbstractList</code> ，实现了 <code>List</code>, <code>RandomAccess</code>, <code>Cloneable</code>, <code>java.io.Serializable</code> 这些接口。</p>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;

  &#125;
</code></pre>
<ul>
<li><code>List</code>: 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li>
<li><code>RandomAccess</code>：这是一个标志接口，表明实现这个接口的 List 集合是支持 <strong>快速随机访问</strong> 的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>Cloneable</code>：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li>
<li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/32809926/1699931892272-96898e4f-7594-4375-92e2-7ddca3b4bdb1.png#averageHue=%232b313a&clientId=ud72f786b-d8fc-4&from=paste&id=ud94899c9&originHeight=330&originWidth=750&originalType=url&ratio=1.1699999570846558&rotation=0&showTitle=false&status=done&style=none&taskId=ue5d171f8-a690-4fb4-9b6d-8696dfd1917&title="></p>
<h4 id="ArrayList-与-Array-的区别"><a href="#ArrayList-与-Array-的区别" class="headerlink" title="ArrayList 与 Array 的区别"></a>ArrayList 与 Array 的区别</h4><p>ArrayList 内部基于动态数组实现，比 Array（静态数组） 使用起来更加灵活：</p>
<ul>
<li>ArrayList会根据实际存储的元素动态地扩容或缩容，而 Array 被创建之后就不能改变它的长度了。</li>
<li>ArrayList 允许你使用泛型来确保类型安全，Array 则不可以。</li>
<li>ArrayList 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。Array 可以直接存储基本类型数据，也可以存储对象。</li>
<li>ArrayList 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 add()、remove()等。Array 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li>
<li>ArrayList创建时不需要指定大小，而Array创建时必须指定大小。</li>
</ul>
<h4 id="Vector-和-Stack-的区别-（了解即可）"><a href="#Vector-和-Stack-的区别-（了解即可）" class="headerlink" title="Vector 和 Stack 的区别?（了解即可）"></a>Vector 和 Stack 的区别?（了解即可）</h4><ul>
<li>Vector 和 Stack 两者都是线程安全的，都是使用 synchronized 关键字进行同步处理。</li>
<li>Stack 继承自 Vector，是一个后进先出的栈，而 Vector 是一个列表。</li>
<li>Vector 和 Stack 已经被淘汰，推荐使用并发集合类（例如 ConcurrentHashMap、CopyOnWriteArrayList 等）或者手动实现线程安全的方法来提供安全的多线程操作支持</li>
</ul>
<h4 id="ArrayList-插入和删除元素的时间复杂度？"><a href="#ArrayList-插入和删除元素的时间复杂度？" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度？"></a>ArrayList 插入和删除元素的时间复杂度？</h4><p>对于插入：</p>
<ul>
<li>头部插入：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部插入：当 ArrayList 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li>
<li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li>
</ul>
<p>对于删除：</p>
<ul>
<li>头部删除：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li>
<li>尾部删除：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li>
<li>指定位置删除：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
<h4 id="LinkedList-插入和删除元素的时间复杂度？"><a href="#LinkedList-插入和删除元素的时间复杂度？" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度？"></a>LinkedList 插入和删除元素的时间复杂度？</h4><ul>
<li>头部插入&#x2F;删除：只需要修改头结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li>
<li>尾部插入&#x2F;删除：只需要修改尾结点的指针即可完成插入&#x2F;删除操作，因此时间复杂度为 O(1)。</li>
<li>指定位置插入&#x2F;删除：需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
<h4 id="LinkedList-为什么不能实现-RandomAccess-接口？"><a href="#LinkedList-为什么不能实现-RandomAccess-接口？" class="headerlink" title="LinkedList 为什么不能实现 RandomAccess 接口？"></a>LinkedList 为什么不能实现 RandomAccess 接口？</h4><p><code>RandomAccess</code>是一个标记接口，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 LinkedList 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 RandomAccess 接口。</p>
<h4 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a><code>Arraylist</code> 与 <code>LinkedList</code> 区别?</h4><ul>
<li><strong>是否保证线程安全：</strong><code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong><code>ArrayList</code> 底层使用的是 <code>**Object**</code>** 数组**；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
<li><strong>插入和删除是否受元素位置的影响：</strong></li>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()</code>），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)，remove(Object o),remove(int index)</code>）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li>
<li><strong>是否支持快速随机访问：</strong><code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong><code>ArrayList</code> 的空间浪费主要体现在在 <code>list</code> 列表的结尾会预留一定的容量空间，而 <code>LinkedList</code> 的空间花费则体现在它的每一个元素都需要消耗比 <code>ArrayList</code> 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<pre><code class="java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;
    private static final long serialVersionUID = 8683452581122892189L;

    /**
     * 默认初始容量大小
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * 空数组（用于空实例）。
     */
    private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

    //用于默认大小空实例的共享空数组实例。
    //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。
    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;

    /**
     * 保存ArrayList数据的数组
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * ArrayList 所包含的元素个数
     */
    private int size;

    /**
     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）
     */
    public ArrayList(int initialCapacity) &#123;
        if (initialCapacity &gt; 0) &#123;
            //如果传入的参数大于0，创建initialCapacity大小的数组
            this.elementData = new Object[initialCapacity];
        &#125; else if (initialCapacity == 0) &#123;
            //如果传入的参数等于0，创建空数组
            this.elementData = EMPTY_ELEMENTDATA;
        &#125; else &#123;
            //其他情况，抛出异常
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot; +
                    initialCapacity);
        &#125;
    &#125;

    /**
     * 默认无参构造函数
     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10
     */
    public ArrayList() &#123;
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;

    /**
     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。
     */
    public ArrayList(Collection&lt;? extends E&gt; c) &#123;
        //将指定集合转换为数组
        elementData = c.toArray();
        //如果elementData数组的长度不为0
        if ((size = elementData.length) != 0) &#123;
            // 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）
            if (elementData.getClass() != Object[].class)
                //将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        &#125; else &#123;
            // 其他情况，用空数组代替
            this.elementData = EMPTY_ELEMENTDATA;
        &#125;
    &#125;

    /**
     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。
     */
    public void trimToSize() &#123;
        modCount++;
        if (size &lt; elementData.length) &#123;
            elementData = (size == 0)
                    ? EMPTY_ELEMENTDATA
                    : Arrays.copyOf(elementData, size);
        &#125;
    &#125;
//下面是ArrayList的扩容机制
//ArrayList的扩容机制提高了性能，如果每次只扩充一个，
//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。

    /**
     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量
     *
     * @param minCapacity 所需的最小容量
     */
    public void ensureCapacity(int minCapacity) &#123;
        //如果是true，minExpand的值为0，如果是false,minExpand的值为10
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // any size if not default element table
                ? 0
                // larger than default for default empty table. It&#39;s already
                // supposed to be at default size.
                : DEFAULT_CAPACITY;
        //如果最小容量大于已有的最大容量
        if (minCapacity &gt; minExpand) &#123;
            ensureExplicitCapacity(minCapacity);
        &#125;
    &#125;

    // 根据给定的最小容量和当前数组元素来计算所需容量。
    private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;
        // 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        &#125;
        // 否则直接返回最小容量
        return minCapacity;
    &#125;

    // 确保内部容量达到指定的最小容量。
    private void ensureCapacityInternal(int minCapacity) &#123;
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    &#125;

    //判断是否需要扩容
    private void ensureExplicitCapacity(int minCapacity) &#123;
        modCount++;
        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            //调用grow方法进行扩容，调用此方法代表已经开始扩容了
            grow(minCapacity);
    &#125;

    /**
     * 要分配的最大数组大小
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * ArrayList扩容的核心方法。
     */
    private void grow(int minCapacity) &#123;
        // oldCapacity为旧容量，newCapacity为新容量
        int oldCapacity = elementData.length;
        //将oldCapacity 右移一位，其效果相当于oldCapacity /2，
        //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        //再检查新容量是否超出了ArrayList所定义的最大容量，
        //若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，
        //如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    &#125;

    //比较minCapacity和 MAX_ARRAY_SIZE
    private static int hugeCapacity(int minCapacity) &#123;
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
                Integer.MAX_VALUE :
                MAX_ARRAY_SIZE;
    &#125;

    /**
     * 返回此列表中的元素数。
     */
    public int size() &#123;
        return size;
    &#125;

    /**
     * 如果此列表不包含元素，则返回 true 。
     */
    public boolean isEmpty() &#123;
        //注意=和==的区别
        return size == 0;
    &#125;

    /**
     * 如果此列表包含指定的元素，则返回true 。
     */
    public boolean contains(Object o) &#123;
        //indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
        return indexOf(o) &gt;= 0;
    &#125;

    /**
     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
     */
    public int indexOf(Object o) &#123;
        if (o == null) &#123;
            for (int i = 0; i &lt; size; i++)
                if (elementData[i] == null)
                    return i;
        &#125; else &#123;
            for (int i = 0; i &lt; size; i++)
                //equals()方法比较
                if (o.equals(elementData[i]))
                    return i;
        &#125;
        return -1;
    &#125;

    /**
     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
     */
    public int lastIndexOf(Object o) &#123;
        if (o == null) &#123;
            for (int i = size - 1; i &gt;= 0; i--)
                if (elementData[i] == null)
                    return i;
        &#125; else &#123;
            for (int i = size - 1; i &gt;= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        &#125;
        return -1;
    &#125;

    /**
     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）
     */
    public Object clone() &#123;
        try &#123;
            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
            //Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度
            v.elementData = Arrays.copyOf(elementData, size);
            v.modCount = 0;
            return v;
        &#125; catch (CloneNotSupportedException e) &#123;
            // 这不应该发生，因为我们是可以克隆的
            throw new InternalError(e);
        &#125;
    &#125;

    /**
     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。
     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。
     */
    public Object[] toArray() &#123;
        return Arrays.copyOf(elementData, size);
    &#125;

    /**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。
     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。
     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。
     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;T&gt; T[] toArray(T[] a) &#123;
        if (a.length &lt; size)
            // 新建一个运行时类型的数组，但是ArrayList数组的内容
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        //调用System提供的arraycopy()方法实现数组之间的复制
        System.arraycopy(elementData, 0, a, 0, size);
        if (a.length &gt; size)
            a[size] = null;
        return a;
    &#125;

    // Positional Access Operations

    @SuppressWarnings(&quot;unchecked&quot;)
    E elementData(int index) &#123;
        return (E) elementData[index];
    &#125;

    /**
     * 返回此列表中指定位置的元素。
     */
    public E get(int index) &#123;
        rangeCheck(index);

        return elementData(index);
    &#125;

    /**
     * 用指定的元素替换此列表中指定位置的元素。
     */
    public E set(int index, E element) &#123;
        //对index进行界限检查
        rangeCheck(index);

        E oldValue = elementData(index);
        elementData[index] = element;
        //返回原来在这个位置的元素
        return oldValue;
    &#125;

    /**
     * 将指定的元素追加到此列表的末尾。
     */
    public boolean add(E e) &#123;
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //这里看到ArrayList添加元素的实质就相当于为数组赋值
        elementData[size++] = e;
        return true;
    &#125;

    /**
     * 在此列表中的指定位置插入指定的元素。
     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
     */
    public void add(int index, E element) &#123;
        rangeCheckForAdd(index);

        ensureCapacityInternal(size + 1);  // Increments modCount!!
        //arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己
        System.arraycopy(elementData, index, elementData, index + 1,
                size - index);
        elementData[index] = element;
        size++;
    &#125;

    /**
     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。
     */
    public E remove(int index) &#123;
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index + 1, elementData, index,
                    numMoved);
        elementData[--size] = null; // clear to let GC do its work
        //从列表中删除的元素
        return oldValue;
    &#125;

    /**
     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。
     * 返回true，如果此列表包含指定的元素
     */
    public boolean remove(Object o) &#123;
        if (o == null) &#123;
            for (int index = 0; index &lt; size; index++)
                if (elementData[index] == null) &#123;
                    fastRemove(index);
                    return true;
                &#125;
        &#125; else &#123;
            for (int index = 0; index &lt; size; index++)
                if (o.equals(elementData[index])) &#123;
                    fastRemove(index);
                    return true;
                &#125;
        &#125;
        return false;
    &#125;

    /*
     * Private remove method that skips bounds checking and does not
     * return the value removed.
     */
    private void fastRemove(int index) &#123;
        modCount++;
        int numMoved = size - index - 1;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index + 1, elementData, index,
                    numMoved);
        elementData[--size] = null; // clear to let GC do its work
    &#125;

    /**
     * 从列表中删除所有元素。
     */
    public void clear() &#123;
        modCount++;

        // 把数组中所有的元素的值设为null
        for (int i = 0; i &lt; size; i++)
            elementData[i] = null;

        size = 0;
    &#125;

    /**
     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) &#123;
        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount
        System.arraycopy(a, 0, elementData, size, numNew);
        size += numNew;
        return numNew != 0;
    &#125;

    /**
     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。
     */
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
        rangeCheckForAdd(index);

        Object[] a = c.toArray();
        int numNew = a.length;
        ensureCapacityInternal(size + numNew);  // Increments modCount

        int numMoved = size - index;
        if (numMoved &gt; 0)
            System.arraycopy(elementData, index, elementData, index + numNew,
                    numMoved);

        System.arraycopy(a, 0, elementData, index, numNew);
        size += numNew;
        return numNew != 0;
    &#125;

    /**
     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。
     * 将任何后续元素移动到左侧（减少其索引）。
     */
    protected void removeRange(int fromIndex, int toIndex) &#123;
        modCount++;
        int numMoved = size - toIndex;
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                numMoved);

        // clear to let GC do its work
        int newSize = size - (toIndex - fromIndex);
        for (int i = newSize; i &lt; size; i++) &#123;
            elementData[i] = null;
        &#125;
        size = newSize;
    &#125;

    /**
     * 检查给定的索引是否在范围内。
     */
    private void rangeCheck(int index) &#123;
        if (index &gt;= size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    &#125;

    /**
     * add和addAll使用的rangeCheck的一个版本
     */
    private void rangeCheckForAdd(int index) &#123;
        if (index &gt; size || index &lt; 0)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    &#125;

    /**
     * 返回IndexOutOfBoundsException细节信息
     */
    private String outOfBoundsMsg(int index) &#123;
        return &quot;Index: &quot; + index + &quot;, Size: &quot; + size;
    &#125;

    /**
     * 从此列表中删除指定集合中包含的所有元素。
     */
    public boolean removeAll(Collection&lt;?&gt; c) &#123;
        Objects.requireNonNull(c);
        //如果此列表被修改则返回true
        return batchRemove(c, false);
    &#125;

    /**
     * 仅保留此列表中包含在指定集合中的元素。
     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。
     */
    public boolean retainAll(Collection&lt;?&gt; c) &#123;
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    &#125;


    /**
     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。
     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。
     * 返回的列表迭代器是fail-fast 。
     */
    public ListIterator&lt;E&gt; listIterator(int index) &#123;
        if (index &lt; 0 || index &gt; size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index);
        return new ListItr(index);
    &#125;

    /**
     * 返回列表中的列表迭代器（按适当的顺序）。
     * 返回的列表迭代器是fail-fast 。
     */
    public ListIterator&lt;E&gt; listIterator() &#123;
        return new ListItr(0);
    &#125;

    /**
     * 以正确的顺序返回该列表中的元素的迭代器。
     * 返回的迭代器是fail-fast 。
     */
    public Iterator&lt;E&gt; iterator() &#123;
        return new Itr();
    &#125;

     //集合A比较与集合B的交集
    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;
         //获得当前对象的所有元素
        final Object[] elementData = this.elementData;
        //w：标记两个集合公共元素的个数
        int r = 0, w = 0;
        //设置标志位
        boolean modified = false;
        try &#123;
            //遍历集合A
            for (; r &lt; size; r++)
                //判断集合B中是否包含集合A中的当前元素
                if (c.contains(elementData[r]) == complement)
                    //如果包含则直接保存。
                    elementData[w++] = elementData[r];
        &#125; finally &#123;
            // 如果 c.contains() 抛出异常
            if (r != size) &#123;
                //复制剩余的元素
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                //w为当前集合A的length
                w += size - r;
            &#125;
            //如果集合A的大小放生改变
            if (w != size) &#123;
                // 清除工作
                for (int i = w; i &lt; size; i++)
                    elementData[i] = null;
                //记录集合中元素的改变(add/remove)
                modCount += size - w;
                //设置当前数组的大小
                size = w;
                //返回为true
                modified = true;
            &#125;
        &#125;
        return modified;
    &#125;

</code></pre>
<h4 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h4><p>从 <code>add(E e)</code>方法开始</p>
<pre><code class="java">    public boolean add(E e) &#123;
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    &#125;

    private void ensureCapacityInternal(int minCapacity) &#123;
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    &#125;

   private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        &#125;
        return minCapacity;
    &#125;

  private void ensureExplicitCapacity(int minCapacity) &#123;
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    &#125;

  private void ensureExplicitCapacity(int minCapacity) &#123;
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);   //扩容方法
    &#125;

  private static int hugeCapacity(int minCapacity) &#123;
        if (minCapacity &lt; 0) // overflow
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
    &#125;
</code></pre>
<p><code> grow(minCapacity)</code>中先会将容量 [<code>newCapacity</code>] 扩容直原容量的 1.5 倍（左右）</p>
<ol>
<li>如果<code>newCapacity</code>比<code>minCapacity</code>大,接着判断新容量是否超出了 ArrayList 的最大容量<br>  1. 超出则执行<code>hugeCapacity(minCapacity)</code><br>  2. 不超出则扩容值<code>newCapacity</code>容量</li>
<li>如果<code>newCapacity</code>比<code>minCapacity</code>小，则<code>newCapacity</code> &#x3D; <code>minCapacity</code>，然后接着判断新容量是否超出了 ArrayList 的最大容量</li>
</ol>
<h4 id="ensureCapacity方法"><a href="#ensureCapacity方法" class="headerlink" title="ensureCapacity方法"></a>ensureCapacity方法</h4><p>理论上来说，最好在向 ArrayList 添加大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数 [ 扩容使用，像是一次扩大很多容量 ]</p>
<pre><code class="java">    /**
    如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。
     *
     * @param   minCapacity   所需的最小容量
     */
    public void ensureCapacity(int minCapacity) &#123;
        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            // any size if not default element table
            ? 0
            // larger than default for default empty table. It&#39;s already
            // supposed to be at default size.
            : DEFAULT_CAPACITY;

        if (minCapacity &gt; minExpand) &#123;
            ensureExplicitCapacity(minCapacity);
        &#125;
    &#125;
</code></pre>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)。详细可以查看：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/linkedlist-source-code.html">源码分析</a><br> 不要下意识地认为 LinkedList 作为链表就最适合元素增删的场景。LinkedList 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的平均时间复杂度都是 O(n)<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32809926/1700037384893-4b16ebd6-d697-43c7-baa4-fd6ac01b60da.png#averageHue=%232b313a&clientId=u44aab232-48aa-4&from=paste&id=u31174d3e&originHeight=455&originWidth=750&originalType=url&ratio=1.1699999570846558&rotation=0&showTitle=false&status=done&style=none&taskId=ua3eb4e0f-46e1-46f4-a6cf-dc6f69f7780&title="></p>
<h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><code>add()</code> 方法有两个版本：</p>
<ul>
<li><code>add(E e)</code>：用于在 <code>LinkedList</code> 的尾部插入元素，即将新元素作为链表的最后一个元素，时间复杂度为 O(1)。</li>
<li>a<code>dd(int index, E element)</code>:用于在指定位置插入元素。这种插入方式需要先移动到指定位置，再修改指定节点的指针完成插入&#x2F;删除，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)。</li>
</ul>
<pre><code class="java">// 在链表尾部插入元素
public boolean add(E e) &#123;
    linkLast(e);
    return true;
&#125;

// 在链表指定位置插入元素
public void add(int index, E element) &#123;
    // 下标越界检查
    checkPositionIndex(index);

    // 判断 index 是不是链表尾部位置
    if (index == size)
        // 如果是就直接调用 linkLast 方法将元素节点插入链表尾部即可
        linkLast(element);
    else
        // 如果不是则调用 linkBefore 方法将其插入指定元素之前
        linkBefore(element, node(index));
&#125;

// 将元素节点插入到链表尾部
void linkLast(E e) &#123;
    // 将最后一个元素赋值（引用传递）给节点 l
    final Node&lt;E&gt; l = last;
    // 创建节点，并指定节点前驱为链表尾节点 last，后继引用为空
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);
    // 将 last 引用指向新节点
    last = newNode;
    // 判断尾节点是否为空
    // 如果 l 是null 意味着这是第一次添加元素
    if (l == null)
        // 如果是第一次添加，将first赋值为新节点，此时链表只有一个元素
        first = newNode;
    else
        // 如果不是第一次添加，将新节点赋值给l（添加前的最后一个元素）的next
        l.next = newNode;
    size++;
    modCount++;
&#125;

// 在指定元素之前插入元素
void linkBefore(E e, Node&lt;E&gt; succ) &#123;
    // assert succ != null;断言 succ不为 null
    // 定义一个节点元素保存 succ 的 prev 引用，也就是它的前一节点信息
    final Node&lt;E&gt; pred = succ.prev;
    // 初始化节点，并指明前驱和后继节点
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);
    // 将 succ 节点前驱引用 prev 指向新节点
    succ.prev = newNode;
    // 判断尾节点是否为空，为空表示当前链表还没有节点
    if (pred == null)
        first = newNode;
    else
        // succ 节点前驱的后继引用指向新节点
        pred.next = newNode;
    size++;
    modCount++;
&#125;
</code></pre>
<h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p>LinkedList获取元素相关的方法一共有 3 个：</p>
<ol>
<li><code>getFirst()</code>：获取链表的第一个元素。</li>
<li><code>getLast()</code>：获取链表的最后一个元素。</li>
<li><code>get(int index)</code>：获取链表指定位置的元素。</li>
</ol>
<pre><code class="java">// 获取链表的第一个元素
public E getFirst() &#123;
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
&#125;

// 获取链表的最后一个元素
public E getLast() &#123;
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return l.item;
&#125;

// 获取链表指定位置的元素
public E get(int index) &#123;
  // 下标越界检查，如果越界就抛异常
  checkElementIndex(index);
  // 返回链表中对应下标的元素
  return node(index).item;
&#125;
</code></pre>
<pre><code class="java">// 返回指定下标的非空节点
Node&lt;E&gt; node(int index) &#123;
    // 断言下标未越界
    // assert isElementIndex(index);
    // 如果index小于size的二分之一  从前开始查找（向后查找）  反之向前查找
    if (index &lt; (size &gt;&gt; 1)) &#123;
        Node&lt;E&gt; x = first;
        // 遍历，循环向后查找，直至 i == index
        for (int i = 0; i &lt; index; i++)
            x = x.next;
        return x;
    &#125; else &#123;
        Node&lt;E&gt; x = last;
        for (int i = size - 1; i &gt; index; i--)
            x = x.prev;
        return x;
    &#125;
&#125;
</code></pre>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p><code>LinkedList</code>删除元素相关的方法一共有 5 个：</p>
<ol>
<li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li>
<li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li>
<li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li>
<li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li>
<li><code>void clear()</code>：移除此链表中的所有元素。</li>
</ol>
<pre><code class="java">// 删除并返回链表的第一个元素
public E removeFirst() &#123;
    final Node&lt;E&gt; f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
&#125;

// 删除并返回链表的最后一个元素
public E removeLast() &#123;
    final Node&lt;E&gt; l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
&#125;

// 删除链表中首次出现的指定元素，如果不存在该元素则返回 fals
public boolean remove(Object o) &#123;
    // 如果指定元素为 null，遍历链表找到第一个为 null 的元素进行删除
    if (o == null) &#123;
        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
            if (x.item == null) &#123;
                unlink(x);
                return true;
            &#125;
        &#125;
    &#125; else &#123;
        // 如果不为 null ,遍历链表找到要删除的节点
        for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123;
            if (o.equals(x.item)) &#123;
                unlink(x);
                return true;
            &#125;
        &#125;
    &#125;
    return false;
&#125;

// 删除链表指定位置的元素
public E remove(int index) &#123;
    // 下标越界检查，如果越界就抛异常
    checkElementIndex(index);
    return unlink(node(index));
&#125;
</code></pre>
<pre><code class="java">E unlink(Node&lt;E&gt; x) &#123;
    // 断言 x 不为 null
    // assert x != null;
    // 获取当前节点（也就是待删除节点）的元素
    final E element = x.item;
    // 获取当前节点的下一个节点
    final Node&lt;E&gt; next = x.next;
    // 获取当前节点的前一个节点
    final Node&lt;E&gt; prev = x.prev;

    // 如果前一个节点为空，则说明当前节点是头节点
    if (prev == null) &#123;
        // 直接让链表头指向当前节点的下一个节点
        first = next;
    &#125; else &#123; // 如果前一个节点不为空
        // 将前一个节点的 next 指针指向当前节点的下一个节点
        prev.next = next;
        // 将当前节点的 prev 指针置为 null，，方便 GC 回收
        x.prev = null;
    &#125;

    // 如果下一个节点为空，则说明当前节点是尾节点
    if (next == null) &#123;
        // 直接让链表尾指向当前节点的前一个节点
        last = prev;
    &#125; else &#123; // 如果下一个节点不为空
        // 将下一个节点的 prev 指针指向当前节点的前一个节点
        next.prev = prev;
        // 将当前节点的 next 指针置为 null，方便 GC 回收
        x.next = null;
    &#125;

    // 将当前节点元素置为 null，方便 GC 回收
    x.item = null;
    size--;
    modCount++;
    return element;
&#125;
</code></pre>
<p>unlink() 方法的逻辑如下：</p>
<ol>
<li>首先获取待删除节点 x 的前驱和后继节点；</li>
<li>判断待删除节点是否为头节点或尾节点： <ul>
<li>如果 x 是头节点，则将 first 指向 x 的后继节点 next</li>
<li>如果 x 是尾节点，则将 last 指向 x 的前驱节点 prev</li>
<li>如果 x 不是头节点也不是尾节点，执行下一步操作</li>
</ul>
</li>
<li>将待删除节点 x 的前驱的后继指向待删除节点的后继 next，断开 x 和 x.prev 之间的链接；</li>
<li>将待删除节点 x 的后继的前驱指向待删除节点的前驱 prev，断开 x 和 x.next 之间的链接；</li>
<li>将待删除节点 x 的元素置空，修改链表长度。</li>
</ol>
<h4 id="遍历列表"><a href="#遍历列表" class="headerlink" title="遍历列表"></a>遍历列表</h4><p>推荐使用<code>for-each</code>循环来遍历<code>LinkedList</code>中的元素,<code>for-each</code> 循环最终会转换成迭代器形式。</p>
<pre><code class="java">LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
list.add(&quot;apple&quot;);
list.add(&quot;banana&quot;);
list.add(&quot;pear&quot;);
for (String fruit : list) &#123;
    System.out.println(fruit);
&#125;
</code></pre>
<p><code>LinkedList</code>的遍历的核心就是它的迭代器的实现。</p>
<pre><code class="java">// 双向迭代器
private class ListItr implements ListIterator&lt;E&gt; &#123;
    // 表示上一次调用 next() 或 previous() 方法时经过的节点；
    private Node&lt;E&gt; lastReturned;
    // 表示下一个要遍历的节点；
    private Node&lt;E&gt; next;
    // 表示下一个要遍历的节点的下标，也就是当前节点的后继节点的下标；
    private int nextIndex;
    // 表示当前遍历期望的修改计数值，用于和 LinkedList 的 modCount 比较，判断链表是否被其他线程修改过。
    private int expectedModCount = modCount;
    …………
&#125;
</code></pre>
<pre><code class="java">// 判断还有没有下一个节点
public boolean hasNext() &#123;
    // 判断下一个节点的下标是否小于链表的大小，如果是则表示还有下一个元素可以遍历
    return nextIndex &lt; size;
&#125;
// 获取下一个节点
public E next() &#123;
    // 检查在迭代过程中链表是否被修改过
    checkForComodification();
    // 判断是否还有下一个节点可以遍历，如果没有则抛出 NoSuchElementException 异常
    if (!hasNext())
        throw new NoSuchElementException();
    // 将 lastReturned 指向当前节点
    lastReturned = next;
    // 将 next 指向下一个节点
    next = next.next;
    nextIndex++;
    return lastReturned.item;
&#125;
</code></pre>
<pre><code class="java">// 判断是否还有前一个节点
public boolean hasPrevious() &#123;
    return nextIndex &gt; 0;
&#125;

// 获取前一个节点
public E previous() &#123;
    // 检查是否在迭代过程中链表被修改
    checkForComodification();
    // 如果没有前一个节点，则抛出异常
    if (!hasPrevious())
        throw new NoSuchElementException();
    // 将 lastReturned 和 next 指针指向上一个节点
    lastReturned = next = (next == null) ? last : next.prev;
    nextIndex--;
    return lastReturned.item;
&#125;
</code></pre>
<p>如果需要删除或插入元素，也可以使用迭代器进行操作。</p>
<pre><code class="java">LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();
list.add(&quot;apple&quot;);
list.add(null);
list.add(&quot;banana&quot;);

//  Collection 接口的 removeIf 方法底层依然是基于迭代器
list.removeIf(Objects::isNull);

for (String fruit : list) &#123;
    System.out.println(fruit);
&#125;
</code></pre>
<p>迭代器对应的移除元素的方法如下：</p>
<pre><code class="java">// 从列表中删除上次被返回的元素
public void remove() &#123;
    // 检查是否在迭代过程中链表被修改
    checkForComodification();
    // 如果上次返回的节点为空，则抛出异常
    if (lastReturned == null)
        throw new IllegalStateException();

    // 获取当前节点的下一个节点
    Node&lt;E&gt; lastNext = lastReturned.next;
    // 从链表中删除上次返回的节点
    unlink(lastReturned);
    // 修改指针
    if (next == lastReturned)
        next = lastNext;
    else
        nextIndex--;
    // 将上次返回的节点引用置为 null，方便 GC 回收
    lastReturned = null;
    expectedModCount++;
&#125;
</code></pre>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)。</li>
</ul>
<h3 id="Comparable-和-Comparator-的区别"><a href="#Comparable-和-Comparator-的区别" class="headerlink" title="Comparable 和 Comparator 的区别"></a>Comparable 和 Comparator 的区别</h3><p><code>Comparable</code>接口和 <code>Comparator</code>接口都是 Java 中用于排序的接口，它们在实现类对象之间比较大小、排序等方面发挥了重要作用：</p>
<ul>
<li>Comparable 接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li>
<li>Comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p>
<h3 id="无序性和不可重复性的含义是什么"><a href="#无序性和不可重复性的含义是什么" class="headerlink" title="无序性和不可重复性的含义是什么"></a>无序性和不可重复性的含义是什么</h3><ul>
<li>无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</li>
<li>不可重复性是指添加的元素按照 equals() 判断时 ，返回 false，需要同时重写 equals() 方法和 hashCode() 方法。</li>
</ul>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li>HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li>HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><ul>
<li><code>PriorityQueue</code>: Object[] 数组来实现小顶堆。详细可以查看：<a href="/java/collection/priorityqueue-source-code.html">PriorityQueue 源码分析</a>。</li>
<li><code>DelayQueue</code>:<code>PriorityQueue</code>。详细可以查看：<a href="/java/collection/delayqueue-source-code.html">DelayQueue 源码分析</a>。</li>
<li><code>ArrayDeque</code>: 可扩容动态双向数组。</li>
</ul>
<h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><p>Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。<br>Queue 扩展了 Collection 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong> 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p>
<table>
<thead>
<tr>
<th>Queue 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队尾</td>
<td>add(E e)</td>
<td>offer(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>remove()</td>
<td>poll()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>element()</td>
<td>peek()</td>
</tr>
</tbody></table>
<p>Deque 是双端队列，在队列的两端均可以插入或删除元素。<br>Deque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p>
<table>
<thead>
<tr>
<th>Deque 接口</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody><tr>
<td>插入队首</td>
<td>addFirst(E e)</td>
<td>offerFirst(E e)</td>
</tr>
<tr>
<td>插入队尾</td>
<td>addLast(E e)</td>
<td>offerLast(E e)</td>
</tr>
<tr>
<td>删除队首</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
</tr>
<tr>
<td>删除队尾</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>查询队首元素</td>
<td>getFirst()</td>
<td>peekFirst()</td>
</tr>
<tr>
<td>查询队尾元素</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
<p>事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。</p>
<h3 id="ArrayDeque-与-LinkedList-的区别"><a href="#ArrayDeque-与-LinkedList-的区别" class="headerlink" title="ArrayDeque 与 LinkedList 的区别"></a>ArrayDeque 与 LinkedList 的区别</h3><p>ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？</p>
<ul>
<li>ArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。</li>
<li>ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。</li>
<li>ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。</li>
<li>ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li>
</ul>
<p>从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。</p>
<h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。<br>这里列举其相关的一些要点：</p>
<ul>
<li>PriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li>
<li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li>
<li>PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li>
<li>PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li>
</ul>
<h2 id="阻塞队列BlockingQueue"><a href="#阻塞队列BlockingQueue" class="headerlink" title="阻塞队列BlockingQueue"></a>阻塞队列BlockingQueue</h2><p>BlockingQueue （阻塞队列）是一个接口，继承自 Queue。BlockingQueue阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</p>
<pre><code class="java">public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123;
    // ...
&#125;
</code></pre>
<p><img src="https://camo.githubusercontent.com/0eabb882889649085c7e2ad119b1a327074c2588a019838e883431385eaeba8a/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f636f6c6c656374696f6e2f626c6f636b696e672d71756575652d6869657261726368792e706e67#from=url&id=z7X2Y&originHeight=640&originWidth=2882&originalType=binary&ratio=1.1699999570846558&rotation=0&showTitle=false&status=done&style=none&title="><br> Java 中常用的阻塞队列实现类有以下几种：</p>
<ol>
<li>ArrayBlockingQueue：使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制。</li>
<li>LinkedBlockingQueue：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为Integer.MAX_VALUE。和ArrayBlockingQueue类似， 它也支持公平和非公平的锁访问机制。</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。元素必须实现Comparable接口或者在构造函数中传入Comparator对象，并且不能插入 null 元素。</li>
<li>SynchronousQueue：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，SynchronousQueue通常用于线程之间的直接传递数据。</li>
<li>DelayQueue：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li>
</ol>
<h3 id="ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？"></a>ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别？</h3><p>ArrayBlockingQueue 和 LinkedBlockingQueue 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。不过，不过它们之间也存在下面这些区别：</p>
<ul>
<li>底层实现：ArrayBlockingQueue 基于数组实现，而 LinkedBlockingQueue 基于链表实现。</li>
<li>是否有界：ArrayBlockingQueue 是有界队列，必须在创建时指定容量大小。LinkedBlockingQueue 创建时可以不指定容量大小，默认是Integer.MAX_VALUE，也就是无界的。但也可以指定队列大小，从而成为有界的。</li>
<li>锁是否分离： ArrayBlockingQueue中的锁是没有分离的，即生产和消费用的是同一个锁；LinkedBlockingQueue中的锁是分离的，即生产用的是putLock，消费是takeLock，这样可以防止生产者和消费者线程之间的锁争夺。</li>
<li>内存占用：ArrayBlockingQueue 需要提前分配数组内存，而 LinkedBlockingQueue 则是动态分配链表节点内存。这意味着，ArrayBlockingQueue 在创建时就会占用一定的内存空间，且往往申请的内存比实际所用的内存更大，而LinkedBlockingQueue 则是根据元素的增加而逐渐占用内存空间。</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul>
<li><code>HashMap</code>：JDK1.8 之前 HashMap 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li>
<li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>：数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ul>
<li><strong>线程是否安全：</strong> <code>HashMap</code>是非线程安全的，<code>Hashtable</code>是线程安全的,因为 Hashtable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。</li>
</ul>
<h3 id="HashMap-和-HashSet-区别"><a href="#HashMap-和-HashSet-区别" class="headerlink" title="HashMap 和 HashSet 区别"></a>HashMap 和 HashSet 区别</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wwwzhouzy/article/details/119654750">https://blog.csdn.net/wwwzhouzy/article/details/119654750</a><br>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<blockquote>
<p>HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个固定对象private static final Object PRESENT &#x3D; new Object();<br>HashSet中add方法调用的是底层HashMap中的put()方法，而如果是在HashMap中调用put，首先会判断key是否存在，如果key存在则修改value值，如果key不存在这插入这个key-value。而在set中，因为value值没有用，也就不存在修改value值的说法，因此往HashSet中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样HashSet中就不存在重复值。<br> 所以判断key是否存在就要重写元素的类的equals()和hashCode()方法，当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算次对象的哈希值，此哈希值决定了此对象在Set中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。</p>
</blockquote>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody><tr>
<td>实现了 Map 接口</td>
<td>实现 Set 接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用 put()向 map 中添加元素</td>
<td>调用 add()方法向 Set 中添加元素</td>
</tr>
<tr>
<td>HashMap 使用键（Key）计算 hashcode</td>
<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以equals()方法用来判断对象的相等性</td>
</tr>
</tbody></table>
<h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。<br><a target="_blank" rel="noopener" href="https://camo.githubusercontent.com/eb4a3e425a51ec14481162669f0a5a0251871c2dc9878f879f6f21c045e3aabe/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f636f6c6c656374696f6e2f747265656d61705f6869657261726368792e706e67"><img src="https://camo.githubusercontent.com/eb4a3e425a51ec14481162669f0a5a0251871c2dc9878f879f6f21c045e3aabe/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f636f6c6c656374696f6e2f747265656d61705f6869657261726368792e706e67#from=url&id=OcPPj&originHeight=269&originWidth=650&originalType=binary&ratio=1.1699999570846558&rotation=0&showTitle=false&status=done&style=none&title="></a><br>实现 NavigableMap 接口让 TreeMap 有了对集合内元素的搜索的能力。<br>实现SortedMap接口让 TreeMap 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<pre><code class="java">/**
 * @author shuang.kou
 * @createTime 2020年06月15日 17:02:00
 */
public class Person &#123;
    private Integer age;

    public Person(Integer age) &#123;
        this.age = age;
    &#125;

    public Integer getAge() &#123;
        return age;
    &#125;


    public static void main(String[] args) &#123;
        TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;(new Comparator&lt;Person&gt;() &#123;
            @Override
            public int compare(Person person1, Person person2) &#123;
                int num = person1.getAge() - person2.getAge();
                return Integer.compare(num, 0);
            &#125;
        &#125;);
        treeMap.put(new Person(3), &quot;person1&quot;);
        treeMap.put(new Person(18), &quot;person2&quot;);
        treeMap.put(new Person(35), &quot;person3&quot;);
        treeMap.put(new Person(16), &quot;person4&quot;);
        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;
            System.out.println(personStringEntry.getValue());
        &#125;);
    &#125;
&#125;
</code></pre>
<p>输出:</p>
<pre><code class="java">person1
person4
person2
person3
</code></pre>
<p>可以看出，TreeMap 中的元素已经是按照 Person 的 age 字段的升序来排列了。<br>可以将代码替换成 Lambda 表达式实现的方式：</p>
<pre><code class="java">TreeMap&lt;Person, String&gt; treeMap = new TreeMap&lt;&gt;((person1, person2) -&gt; &#123;
    int num = person1.getAge() - person2.getAge();
    return Integer.compare(num, 0);
&#125;);
</code></pre>
<p><strong>相比于HashMap来说 TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><code>HashMap</code>主要用来存放键值对，它基于哈希表的 <code>Map</code> 接口实现，是常用的 Java 集合之一，是非线程安全的。<br><code>HashMap</code> 可以存储 <code>null</code> 的 <code>key</code> 和 <code>value</code>，但 <code>null</code> 作为键只能有一个，<code>null</code> 作为值可以有多个<br><code>HashMap </code>默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且<code>HashMap</code>总是使用 2 的幂作为哈希表的大小<br>:::info<br>HashMap 的迭代顺序并不是按照元素插入顺序来的,因为存储元素的方式是按计算出的 hash 来确定元素在散列表等结构中的位置的.所以也就存在一个现象,两个相同的元素列表存入 hashmap 的时候,如果使用相同的 hash 计算方式,那它们在散列表中的存放位置其实是相同的<br>:::</p>
<h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        //声明了一个局部变量 tab,局部变量 Node 类型的数据 p,int 类型 n,i
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
        //首先将当前 hashmap 中的 table(哈希表)赋值给当前的局部变量 tab,然后判断tab 是不是空或者长度是不是 0,实际上就
        //是判断当前 hashmap 中的哈希表是不是空或者长度等于 0
        if ((tab = table) == null || (n = tab.length) == 0)
        //如果是空的或者长度等于0,代表现在还没哈希表,所以需要创建新的哈希表,默认就是创建了一个长度为 16 的哈希表
            n = (tab = resize()).length;
        //将当前哈希表中与要插入的数据位置对应的数据取出来,(n - 1) &amp; hash])就是找当前要插
        //入的数据应该在哈希表中的位置,如果没找到,代表哈希表中当前的位置是空的,否则就代表找到数据了, 并赋值给变量 p
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            tab[i] = newNode(hash, key, value, null);//创建一个新的数据,这个数据没有下一条,并将数据放到当前这个位置
        else &#123;//代表要插入的数据所在的位置是有内容的
        //声明了一个节点 e, 一个 key k
            Node&lt;K,V&gt; e; K k;
            if (p.hash == hash &amp;&amp; //如果当前位置上的那个数据的 hash 和我们要插入的 hash 是一样,代表没有放错位置
            //如果当前这个数据的 key 和我们要放的 key 是一样的,实际操作应该是就替换值
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                //将当前的节点赋值给局部变量 e
                e = p;
            else if (p instanceof TreeNode)//如果当前节点的 key 和要插入的 key 不一样,然后要判断当前节点是不是一个红黑色类型的节点
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//如果是就创建一个新的树节点,并把数据放进去
            else &#123;
                //如果不是树节点,代表当前是一个链表,那么就遍历链表
                for (int binCount = 0; ; ++binCount) &#123;
                    if ((e = p.next) == null) &#123;//如果当前节点的下一个是空的,就代表没有后面的数据了
                        p.next = newNode(hash, key, value, null);//创建一个新的节点数据并放到当前遍历的节点的后面
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // 重新计算当前链表的长度是不是超出了限制
                            treeifyBin(tab, hash);//超出了之后就将当前链表转换为树,注意转换树的时候,如果当前数组的长度小于
                            //MIN_TREEIFY_CAPACITY(默认 64),会触发扩容,我个人感觉可能是因为觉得一个节点下面的数据都超过8 了,
                            //说明 hash寻址重复的厉害(比如数组长度为 16 ,hash 值刚好是 0或者 16 的倍数,导致都去同一个位置),需要重新扩容重新 hash
                        break;
                    &#125;
                    //如果当前遍历到的数据和要插入的数据的 key 是一样,和上面之前的一样,赋值给变量 e,下面替换内容
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                &#125;
            &#125;
            if (e != null) &#123; //如果当前的节点不等于空,
                V oldValue = e.value;//将当前节点的值赋值给 oldvalue
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value; //将当前要插入的 value 替换当前的节点里面值
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;//增加长度
        if (++size &gt; threshold)
            resize();//如果当前的 hash表的长度已经超过了当前 hash 需要扩容的长度, 重新扩容,条件是
            // haspmap 中存放的数据超过了临界值(经过测试),而不是数组中被使用的下标
        afterNodeInsertion(evict);
        return null;
    &#125;
</code></pre>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><pre><code class="java">public V get(Object key) &#123;
        Node&lt;K,V&gt; e;
        return (e = getNode(hash(key), key)) == null ? null : e.value;
    &#125;
    /*
     关于为什么每次都检测第一个node,个人认为是因为第一个node在数组上,用不着在树或链表中查询
    */
    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (first = tab[(n - 1) &amp; hash]) != null) &#123;
            if (first.hash == hash &amp;&amp; // always check first node
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;
            if ((e = first.next) != null) &#123;
                if (first instanceof TreeNode)
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
                do &#123;
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        return e;
                &#125; while ((e = e.next) != null);
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<h4 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h4><p> 进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素。resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。【非常耗时】</p>
<pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) &#123;
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        // 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量
        newCap = oldThr;
    else &#123;
        // signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    if (newThr == 0) &#123;
        // 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，
        // 或者扩容前的旧容量小于16，在这里计算新的resize上限
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    &#125;
    threshold = newThr;
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) &#123;
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                if (e.next == null)
                    // 只有一个节点，直接计算元素新的位置即可
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    // 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。
                    // 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123;
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        // 原索引
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        // 原索引+oldCap
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><code>LinkedHashMap</code>的迭代顺序是和插入顺序一致的,这一点是<code>HashMap</code>所不具备的</p>
<h4 id="访问顺序遍历"><a href="#访问顺序遍历" class="headerlink" title="访问顺序遍历"></a>访问顺序遍历</h4><p><code>LinkedHashMap</code>定义了排序模式 <code>accessOrder</code>(boolean 类型，默认为 false)，访问顺序则为 true，插入顺序则为 false。<br>为了实现访问顺序遍历，我们可以使用传入 accessOrder 属性的 LinkedHashMap 构造方法，并将 accessOrder 设置为 true，表示其具备访问有序性。</p>
<pre><code class="java">LinkedHashMap&lt;Integer, String&gt; map = new LinkedHashMap&lt;&gt;(16, 0.75f, true);
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
map.put(4, &quot;four&quot;);
map.put(5, &quot;five&quot;);
//访问元素2,该元素会被移动至链表末端
map.get(2);
//访问元素3,该元素会被移动至链表末端
map.get(3);
for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;
    System.out.println(entry.getKey() + &quot; : &quot; + entry.getValue());
&#125;
//输出:
// 1 : one
// 4 : four
// 5 : five
// 2 : two
// 3 : three
</code></pre>
<h4 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h4><p>通过 <code>LinkedHashMap</code>我们可以封装一个简易版的 LRU（<strong>L</strong>east <strong>R</strong>ecently <strong>U</strong>sed，最近最少使用） 缓存，确保当存放的元素超过容器容量时，将最近最少访问的元素移除。<br><img src="https://cdn.nlark.com/yuque/0/2023/png/32809926/1701842991555-6fc01040-028f-47ee-aefc-25fe2565f0b3.png#averageHue=%23f7f5f5&clientId=u9c6ab9ff-a1a2-4&from=paste&id=u8a82fc79&originHeight=173&originWidth=826&originalType=url&ratio=1.1699999570846558&rotation=0&showTitle=false&status=done&style=none&taskId=u42e31801-6e90-4839-994b-314f989a4a4&title="><br>具体实现思路如下：</p>
<ul>
<li>继承 LinkedHashMap;</li>
<li>构造方法中指定 accessOrder 为 true ，这样在访问元素时就会把该元素移动到链表尾部，链表首元素就是最近最少被访问的元素；</li>
<li>重写<code>removeEldestEntry</code> 方法，该方法会返回一个 boolean 值，告知 LinkedHashMap 是否需要移除链表首元素（缓存容量有限）。</li>
</ul>
<pre><code class="java">public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;
    private final int capacity;

    public LRUCache(int capacity) &#123;
        super(capacity, 0.75f, true);
        this.capacity = capacity;
    &#125;

    /**
     * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)
     */
    @Override
    protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123;
        return size() &gt; capacity;
    &#125;
&#125;

    //测试代码
public static void main(String[] args)&#123;
    LRUCache &lt; Integer, String &gt; cache = new LRUCache &lt; &gt; (2);
    cache.put(1, &quot;one&quot;);
    cache.put(2, &quot;two&quot;);
    cache.put(3, &quot;three&quot;);
    cache.put(4, &quot;four&quot;);
    for (int i = 0; i &lt; 4; i++) &#123;
        System.out.println(cache.get(i));
    &#125;
&#125;
//output:   null
            null
            three
            four
//从输出结果来看，由于缓存容量为 2 ，因此，添加第 3 个元素时，第 1 个元素会被删除。添加第 4 个元素时，第 2 个元素会被删除
</code></pre>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="Node-的设计"><a href="#Node-的设计" class="headerlink" title="Node 的设计"></a>Node 的设计</h5><p>LinkedHashMap 是在 HashMap 的基础上为 bucket 上的每一个节点建立一条双向链表，这就使得转为红黑树的树节点也需要具备双向链表节点的特性，即每一个树节点都需要拥有两个引用存储前驱节点和后继节点的地址,所以对于树节点类 TreeNode 的设计就是一个比较棘手的问题。<br>对此我们不妨来看看两者之间节点类的类图，可以看到:</p>
<ol>
<li>LinkedHashMap 的节点内部类 Entry 基于 HashMap 的基础上，增加 before 和 after 指针使节点具备双向链表的特性。</li>
<li>HashMap 的树节点 TreeNode 继承了具备双向链表特性的 LinkedHashMap 的 Entry。</li>
</ol>
<p><img src="https://camo.githubusercontent.com/35f543e756571580ff6c7d9f2728be4fc3f94eed0a472db306be150422d3ee9a/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f636f6c6c656374696f6e2f6d61702d686173686d61702d6c696e6b6564686173686d61702e706e67#from=url&height=621&id=NxLD5&originHeight=2106&originWidth=1502&originalType=binary&ratio=1.1699999570846558&rotation=0&showTitle=false&status=done&style=none&title=&width=442.81463623046875"></p>
<ul>
<li>为什么 HashMap 的树节点 TreeNode 要通过 LinkedHashMap 获取双向链表的特性呢?为什么不直接在 Node 上实现前驱和后继指针呢?</li>
</ul>
<p>先来回答第一个问题，我们都知道 LinkedHashMap 是在 HashMap 基础上对节点增加双向指针实现双向链表的特性,所以 LinkedHashMap 内部链表转红黑树时，对应的节点会转为树节点 TreeNode,为了保证使用 LinkedHashMap 时树节点具备双向链表的特性，所以树节点 TreeNode 需要继承 LinkedHashMap 的 Entry。<br>再来说说第二个问题，我们直接在 HashMap 的节点 Node 上直接实现前驱和后继指针,然后 TreeNode 直接继承 Node 获取双向链表的特性为什么不行呢？其实这样做也是可以的。只不过这种做法会使得使用 HashMap 时存储键值对的节点类 Node 多了两个没有必要的引用，占用没必要的内存空间。<br>所以，为了保证 HashMap 底层的节点类 Node 没有多余的引用，又要保证 LinkedHashMap 的节点类 Entry 拥有存储链表的引用，设计者就让 LinkedHashMap 的节点 Entry 去继承 Node 并增加存储前驱后继节点的引用 before、after，让需要用到链表特性的节点去实现需要的逻辑。然后树节点 TreeNode 再通过继承 Entry 获取 before、after 两个指针。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><pre><code class="java">public LinkedHashMap() &#123;
    super();
    accessOrder = false;
&#125;

public LinkedHashMap(int initialCapacity) &#123;
    super(initialCapacity);
    accessOrder = false;
&#125;

public LinkedHashMap(int initialCapacity, float loadFactor) &#123;
    super(initialCapacity, loadFactor);
    accessOrder = false;
&#125;

public LinkedHashMap(int initialCapacity,
    float loadFactor,
    boolean accessOrder) &#123;
    super(initialCapacity, loadFactor);
    this.accessOrder = accessOrder;
&#125;
</code></pre>
<p>默认情况下 <code>accessOrder</code>为 false，如果我们要让 LinkedHashMap 实现键值对按照访问顺序排序(即将最近未访问的元素排在链表首部、最近访问的元素移动到链表尾部)，需要调用第 4 个构造方法将 accessOrder 设置为 true。</p>
<h5 id="get-1"><a href="#get-1" class="headerlink" title="get()"></a>get()</h5><pre><code class="java">  public V get(Object key) &#123;
        Node&lt;K,V&gt; e;
        if ((e = getNode(hash(key), key)) == null)
            return null;
        if (accessOrder)
            afterNodeAccess(e);
        return e.value;
    &#125;

void afterNodeAccess(Node &lt; K, V &gt; e) &#123; // move node to last
    LinkedHashMap.Entry &lt; K, V &gt; last;
    //如果accessOrder 且当前节点不未链表尾节点
    if (accessOrder &amp;&amp; (last = tail) != e) &#123;

        //获取当前节点、以及前驱节点和后继节点
        LinkedHashMap.Entry &lt; K, V &gt; p =
            (LinkedHashMap.Entry &lt; K, V &gt; ) e, b = p.before, a = p.after;

        //将当前节点的后继节点指针指向空，使其和后继节点断开联系
        p.after = null;

        //如果前驱节点为空，则说明当前节点是链表的首节点，故将后继节点设置为首节点
        if (b == null)
            head = a;
        else
            //如果后继节点不为空，则让前驱节点指向后继节点
            b.after = a;

        //如果后继节点不为空，则让后继节点指向前驱节点
        if (a != null)
            a.before = b;
        else
            //如果后继节点为空，则说明当前节点在链表最末尾，直接让last 指向前驱节点,这个 else其实 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null
            last = b;

        //如果last为空，则说明当前链表只有一个节点p，则将head指向p
        if (last == null)
            head = p;
        else &#123;
            //反之让p的前驱指针指向尾节点，再让尾节点的前驱指针指向p
            p.before = last;
            last.after = p;
        &#125;
        //tail指向p，自此将节点p移动到链表末尾
        tail = p;

        ++modCount;
    &#125;
&#125;
</code></pre>
<h5 id="remove-方法后置操作afterNodeRemoval"><a href="#remove-方法后置操作afterNodeRemoval" class="headerlink" title="remove 方法后置操作afterNodeRemoval()"></a>remove 方法后置操作<code>afterNodeRemoval()</code></h5><p>LinkedHashMap 并没有对 remove 方法进行重写，而是直接继承 HashMap 的 remove 方法，为了保证键值对移除后双向链表中的节点也会同步被移除，LinkedHashMap 重写了 HashMap 的空实现方法 <code>afterNodeRemoval</code>。</p>
<pre><code class="java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) &#123;
        //略
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) &#123;
                if (node instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    tab[index] = node.next;
                else
                    p.next = node.next;
                ++modCount;
                --size;
                //HashMap的removeNode完成元素移除后会调用afterNodeRemoval进行移除后置操作
                afterNodeRemoval(node);
                return node;
            &#125;
        &#125;
        return null;
    &#125;
//空实现
void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;
</code></pre>
<p>从 HashMap 继承来的 remove 方法内部调用的 removeNode 方法将节点从 bucket 删除后，调用了 afterNodeRemoval。</p>
<pre><code class="java">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink

        //获取当前节点p、以及e的前驱节点b和后继节点a
        LinkedHashMap.Entry&lt;K,V&gt; p =
            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        //将p的前驱和后继指针都设置为null，使其和前驱、后继节点断开联系
        p.before = p.after = null;

        //如果前驱节点为空，则说明当前节点p是链表首节点，让head指针指向后继节点a即可
        if (b == null)
            head = a;
        else
        //如果前驱节点b不为空，则让b直接指向后继节点a
            b.after = a;

        //如果后继节点为空，则说明当前节点p在链表末端，所以直接让tail指针指向前驱节点a即可
        if (a == null)
            tail = b;
        else
        //反之后继节点的前驱指针直接指向前驱节点
            a.before = b;
    &#125;
</code></pre>
<h5 id="put-方法后置操作afterNodeInsertion"><a href="#put-方法后置操作afterNodeInsertion" class="headerlink" title="put 方法后置操作afterNodeInsertion()"></a>put 方法后置操作<code>afterNodeInsertion()</code></h5><pre><code class="java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
            //略
            if (e != null) &#123; // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                 //如果当前的key在map中存在，则调用afterNodeAccess
                afterNodeAccess(e);
                return oldValue;
            &#125;
        &#125;
        ++modCount;
        if (++size &gt; threshold)
            resize();
         //调用插入后置方法，该方法被LinkedHashMap重写
        afterNodeInsertion(evict);
        return null;
    &#125;
</code></pre>
<p>假设我们的重写了 removeEldestEntry，当链表 size 超过 capacity 时，就返回 true。</p>
<pre><code class="java">/**
 * 判断size超过容量时返回true，告知LinkedHashMap移除最老的缓存项(即链表的第一个元素)
 */
protected boolean removeEldestEntry(Map.Entry &lt; K, V &gt; eldest) &#123;
    return size() &gt; capacity;
&#125;
</code></pre>
<pre><code class="java">void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest
        LinkedHashMap.Entry&lt;K,V&gt; first;
        //如果evict为true且队首元素不为空以及removeEldestEntry返回true，
        //则说明我们需要最老的元素(即在链表首部的元素)移除。
        if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123;
            //获取链表首部的键值对的key
            K key = first.key;
            //调用removeNode将元素从HashMap的bucket中移除，并和LinkedHashMap的双向链表断开，等待gc回收
            removeNode(hash(key), key, null, false, true);
        &#125;
    &#125;
</code></pre>
<p>调用 HashMap 的 <code>removeNode</code>方法，它会将节点从 HashMap 的 bucket 中移除，并且 LinkedHashMap 还重写了 removeNode 中的 <code>afterNodeRemoval</code>方法，所以这一步将通过调用 <code>removeNode</code>将元素从 HashMap 的 bucket 中移除，并和 LinkedHashMap 的双向链表断开，等待 gc 回收。</p>
<h3 id="LinkedHashMap-和-HashMap-遍历性能比较"><a href="#LinkedHashMap-和-HashMap-遍历性能比较" class="headerlink" title="LinkedHashMap 和 HashMap 遍历性能比较"></a>LinkedHashMap 和 HashMap 遍历性能比较</h3><p>LinkedHashMap 维护了一个双向链表来记录数据插入的顺序，因此在迭代遍历生成的迭代器的时候，是按照双向链表的路径进行遍历的。这一点相比于 HashMap 那种遍历整个 bucket 的方式来说，高效需多。<br>这一点可以从两者的迭代器中得以印证，HashMap 迭代键值对时会用到一个 nextNode 方法，该方法会返回 next 指向的下一个元素，并会从 next 开始遍历 bucket 找到下一个 bucket 中不为空的元素 Node。</p>
<pre><code class="java"> final class EntryIterator extends HashIterator
 implements Iterator &lt; Map.Entry &lt; K, V &gt;&gt; &#123;
     public final Map.Entry &lt; K,
     V &gt; next() &#123;
         return nextNode();
     &#125;
 &#125;

 //获取下一个Node
 final Node &lt; K, V &gt; nextNode() &#123;
     Node &lt; K, V &gt; [] t;
     //获取下一个元素next
     Node &lt; K, V &gt; e = next;
     if (modCount != expectedModCount)
         throw new ConcurrentModificationException();
     if (e == null)
         throw new NoSuchElementException();
     //将next指向bucket中下一个不为空的Node
     if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;
         do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);
     &#125;
     return e;
 &#125;
</code></pre>
<p>相比之下 LinkedHashMap 的迭代器则是直接使用通过 after 指针快速定位到当前节点的后继节点，简洁高效需多。</p>
<pre><code class="java"> final class LinkedEntryIterator extends LinkedHashIterator
 implements Iterator &lt; Map.Entry &lt; K, V &gt;&gt; &#123;
     public final Map.Entry &lt; K,
     V &gt; next() &#123;
         return nextNode();
     &#125;
 &#125;
 //获取下一个Node
 final LinkedHashMap.Entry &lt; K, V &gt; nextNode() &#123;
     //获取下一个节点next
     LinkedHashMap.Entry &lt; K, V &gt; e = next;
     if (modCount != expectedModCount)
         throw new ConcurrentModificationException();
     if (e == null)
         throw new NoSuchElementException();
     //current 指针指向当前节点
     current = e;
     //next直接当前节点的after指针快速定位到下一个节点
     next = e.after;
     return e;
 &#125;
</code></pre>
<h3 id="遍历的方法："><a href="#遍历的方法：" class="headerlink" title="遍历的方法："></a>遍历的方法：</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a><br>通过Map.keySet遍历key和value<br>keySet()<br>通过Map.entrySet使用iterator遍历key和value<br>entrySet()<br>第三种：通过Map.entrySet遍历key和value<br>通过Map.values()遍历所有的value，但不能遍历key</p>
<h2 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="retainAll-源码"><a href="#retainAll-源码" class="headerlink" title="retainAll()源码"></a>retainAll()源码</h4><p>retainAll(Collections&lt;?&gt; c) 获取两个集合的交集</p>
<pre><code class="java">public boolean retainAll(Collection&lt;?&gt; c) &#123;
        Objects.requireNonNull(c);
        return batchRemove(c, true);
    &#125;

    private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123;
        final Object[] elementData = this.elementData;
        int r = 0, w = 0;
        boolean modified = false;
        try &#123;
            for (; r &lt; size; r++)
                if (c.contains(elementData[r]) == complement)
                    elementData[w++] = elementData[r];               //这部分循环是为了将交集的部分前移
        &#125; finally &#123;
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) &#123;
                System.arraycopy(elementData, r,
                                 elementData, w,
                                 size - r);
                w += size - r;
            &#125;
            if (w != size) &#123;
                // clear to let GC do its work
                for (int i = w; i &lt; size; i++)                    //这部分是为了将调用该方法的集合的剩余部分置为null
                    elementData[i] = null;
                modCount += size - w;                             //更新modCount 修改次数
                size = w;
                modified = true;
            &#125;
        &#125;
        return modified;
    &#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/14/%E9%9B%86%E5%90%88/" data-id="clq57xl2500025lwofqj5cloy" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-mytest" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/14/mytest/" class="article-date">
  <time class="dt-published" datetime="2023-12-14T11:39:17.000Z" itemprop="datePublished">2023-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/14/mytest/">mytest</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/14/mytest/" data-id="clq57xl2100005lwoa0s26sn2" data-title="mytest" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/14/hello-world/" class="article-date">
  <time class="dt-published" datetime="2023-12-14T11:18:10.114Z" itemprop="datePublished">2023-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/14/hello-world/" data-id="clq57xl2400015lwoa4hg919w" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">December 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/14/%E9%9B%86%E5%90%88/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/12/14/mytest/">mytest</a>
          </li>
        
          <li>
            <a href="/2023/12/14/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
